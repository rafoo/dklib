#NAME dk_zeta_FO

(; First Order ç-calculus ;)

label := dk_lrecords.label.
Label := cc.eT label.
Domain := dk_lrecords.Domain.
label_eq := dk_lrecords.label_eq.
bool := dk_bool.bool.
Bool := cc.eT bool.
istrue := b : Bool => dk_logic.eeP (dk_logic.ebP b).
Istrue := b : Bool => cc.eT (istrue b).

(; Object/expression types are records of types ;)
TTyper := l : Label => cc.uuT. (; Typer for types ;)
Record := dk_lrecords.AssocT_list TTyper.

AssocTT_cons := dk_lrecords.AssocT_cons TTyper.
AssocTT_nil := dk_lrecords.AssocT_nil TTyper.
mk_coupleTT := dk_lrecords.mk_couple TTyper.


expr : Record -> cc.uT.
Expr : Record -> Type
 := r : Record => cc.eT (expr r).

(; Methods are functions from expressions to anything ;)
method := r : Record =>
          A : cc.uT =>
          cc.Arrow (expr r) A.
Method := r : Record =>
          A : cc.uT =>
          Expr r -> cc.eT A.

(; With couples ;)
cmethod := r : Record =>
           c : cc.eT (dk_lrecords.couple TTyper) =>
           dk_lrecords.mk_couple TTyper
             (dk_lrecords.fstT TTyper c)
             (method r (dk_lrecords.sndT TTyper c)).

(; mapped to a Record ;)
map_cmethod : Record -> Record :=
              r : Record =>
              (dk_list.map
                (dk_lrecords.couple TTyper)
                (dk_lrecords.couple TTyper)
                (cmethod r)
                r).

(; We usually need A = r l for some label l ;)

lmethod := r : Record =>
           l : Label => dk_lrecords.assocTT_val (map_cmethod r) l.
Lmethod := r : Record =>
           l : Label => cc.eT (lmethod r l).

object : Record -> cc.uT := r : Record => dk_lrecords.assocR_list (map_cmethod r).

Object : Record -> Type := r : Record => cc.eT (object r).

Empty : Record := AssocTT_nil.

empty_object : Object Empty := dk_lrecords.AssocR_nil (map_cmethod Empty).
(; The updated method keep the same type r l. ;)

update_object : r : Record ->
                Object r ->
                l : Label ->
                m : Lmethod r l ->
                Object r
:=
                r : Record =>
                o : Object r =>
                l : Label =>
                m : Lmethod r l =>
                dk_lrecords.AssocR_cons
                  (map_cmethod r)
                  (dk_lrecords.mk_coupleR (map_cmethod r) l m)
                  o.

make : r : Record -> Object r -> Expr r.
select : r : Record ->
         Expr r ->
         l : Label ->
         cc.eT (dk_lrecords.assocT_val dk_lrecords.TTyper (dk_list.map (dk_lrecords.couple TTyper) (dk_lrecords.couple TTyper) (c:(cc.eT (dk_lrecords.couple TTyper)) => dk_lrecords.mk_couple TTyper (dk_lrecords.fstT TTyper c) (method r (dk_lrecords.sndT TTyper c))) r) l).
update : r : Record ->
         Expr r ->
         l : Label ->
         Lmethod r l ->
         Expr r.

[r : Record,
 o : Object r,
 l : Label]
   select r (make _ o) l
      -->
   dk_lrecords.assocR_val
     (map_cmethod r)
     o
       l.


[r : Record,
 o : Object r,
 l : Label,
 m : Lmethod r l]
   update r (make _ o) l m
    --> make r (update_object r o l m).

(; Exemples;)
l_if : Label := dk_list.cons dk_char.char dk_char.i (
                dk_list.cons dk_char.char dk_char.f (
                dk_list.nil dk_char.char)).
l_then : Label := dk_list.cons dk_char.char dk_char.t (
                  dk_list.cons dk_char.char dk_char.h (
                  dk_list.cons dk_char.char dk_char.e (
                  dk_list.cons dk_char.char dk_char.n (
                  dk_list.nil dk_char.char)))).
l_else : Label := dk_list.cons dk_char.char dk_char.e (
                  dk_list.cons dk_char.char dk_char.l (
                  dk_list.cons dk_char.char dk_char.s (
                  dk_list.cons dk_char.char dk_char.e (
                  dk_list.nil dk_char.char)))).
d_ite : Domain := dk_lrecords.domain_cons l_if (
                  dk_lrecords.domain_cons l_then (
                  dk_lrecords.domain_cons l_else (
                  dk_lrecords.domain_nil))).

BoolT : A : cc.uT -> Record
     := A : cc.uT =>
              (AssocTT_cons (mk_coupleTT l_if A) (
               AssocTT_cons (mk_coupleTT l_then A) (
               AssocTT_cons (mk_coupleTT l_else A) (
               AssocTT_nil)))).

trueT : A : cc.uT -> Expr (BoolT A)
      := A : cc.uT =>
         update
           (BoolT A)
           (update
             (BoolT A)
             (update
               (BoolT A)
               (make (BoolT A) empty_object)
                 l_if
                 (self : Expr (BoolT A) => select (BoolT A) self l_then)
             )
             l_then
               (self : Expr d_ite (BoolT A) => select (BoolT A) self l_then)
           )
           l_else
             (self : Expr d_ite (BoolT A) => select (BoolT A) self l_else).

falseT : A : cc.uT -> Expr d_ite (BoolT A)
      := A : cc.uT =>
         make d_ite (BoolT A)
           (l : Label =>
              dk_lrecords.if_label_eq (lmethod d_ite (BoolT A)) l_if l
                (self : Expr d_ite (BoolT A) => select d_ite (BoolT A) self l_else)
                (dk_lrecords.if_label_eq (lmethod d_ite (BoolT A)) l_then l
                   (self : Expr d_ite (BoolT A) => select d_ite (BoolT A) self l_then)
                   (dk_lrecords.if_label_eq (lmethod d_ite (BoolT A)) l_else l
                      (self : Expr d_ite (BoolT A) => select d_ite (BoolT A) self l_else)
                      (; Default case ;)
                      (self : Expr d_ite (BoolT A) => dk_fail.fail (BoolT A l))))).

ifT : A : cc.uT -> Expr d_ite (BoolT A) -> cc.eT A -> cc.eT A -> cc.eT A
    := A : cc.uT =>
       b : Expr d_ite (BoolT A) =>
       then : cc.eT A =>
       else : cc.eT A =>
       select d_ite (BoolT A)
         (update d_ite (BoolT A)
           (update d_ite (BoolT A)
             b
             l_then
             (self : Expr d_ite (BoolT A) => then))
           l_else
           (self : Expr d_ite (BoolT A) => else))
         l_if.

(; A : cc.uT. ;)
(; t : cc.eT A. ;)
(; e : cc.eT A. ;)
(; #ASSERT (ifT A (trueT A) t e) ~= t. ;)
(; #ASSERT (ifT A (falseT A) t e) ~= e. ;)

(; Sous-typage ;)
(; cast_type : DA : Domain -> ;)
(;             DB : Domain -> ;)
(;             RA : Record DA -> ;)
(;             RB : Record DB -> ;)
(;             Record DB. ;)

(; [ DA : Domain, ;)
(;   RA : Record DA, ;)
(;   RB : Record (dk_lrecords.domain_nil) ] ;)
(;   cast_type DA dk_lrecords.domain_nil RA RB --> RB. ;)

(; [ DA : Domain, ;)
(;   l : Label, ;)
(;   DB : Domain ;)
(;   RA : Record DA, ;)
(;   RB : Record (dk_lrecords.domain_cons l DB) ] ;)
(;   cast_type DA (dk_lrecords.domain_cons l DB) RA RB ;)
(;       --> ;)
(;   dk_lrecords. ;)
(; . ;)

ocast : DA : Domain ->
        DB : Domain ->
        RA : Record DA ->
        RB : Record DB ->
        Object DA RA ->
        Object DB (dk_lrecords.Record_subtype TTyper DA DB RA RB).

[ DA : Domain,
  RA : Record DA,
  RB : Record dk_lrecords.domain_nil,
  oA : Object DA RA,
  l : Label,
  self : Expr dk_lrecords.domain_nil RB]
    ocast DA (dk_list.nil _) RA RB oA l self
      -->
    dk_fail.fail (RB l).

[ DA : Domain,
  l1 : Label,
  DB : Domain,
  RA : Record DA,
  RB : Record (dk_lrecords.domain_cons l1 DB),
  oA : Object DA RA,
  l2 : Label,
  self : Expr
    (dk_lrecords.domain_cons l1 DB)
    (dk_lrecords.Record_subtype TTyper DA (dk_lrecords.domain_cons l1 DB) RA RB)]
    ocast DA (dk_list.cons _ l1 DB) RA RB oA l2 self
      -->
    dk_lrecords.if_label_eq (dk_lrecords.Record_subtype TTyper DA (dk_lrecords.domain_cons l1 DB) RA RB)
                l1 l2
                  (select DA RA (make DA RA oA) l1)
                  (select
                    DB
                    (dk_lrecords.Record_subtype TTyper DA (dk_lrecords.domain_cons l1 DB) RA RB)
                    (make
                      DB
                      (dk_lrecords.Record_subtype TTyper DA (dk_lrecords.domain_cons l1 DB) RA RB)
                      (ocast DA DB RA RB oA))
                    l2).




cast : DA : Domain ->
       DB : Domain ->
       RA : Record DA ->
       RB : Record DB ->
       Expr DA RA ->
       Expr DB (dk_lrecords.Record_subtype TTyper DA DB RA RB).

[ DA : Domain,
  DB : Domain,
  RA : Record DA,
  RB : Record DB,
  oA : Object DA RA]
    cast DA DB RA RB (make _ _ oA)
-->
    make DB RA (ocast DA DB RA RB oA).

(; Exemple ;)
l_get : Label := dk_list.cons dk_char.char dk_char.g (
                 dk_list.cons dk_char.char dk_char.e (
                 dk_list.cons dk_char.char dk_char.t (
                 dk_list.nil dk_char.char))).
d_get : Domain := dk_lrecords.domain_cons l_get (
                  dk_lrecords.domain_nil).

RomCell : Record d_get
:=
     dk_lrecords.AssocT_list_record
               (l : Label => cc.uuT)
               (AssocTT_cons (mk_coupleTT l_get dk_nat.Nat) (
               AssocTT_nil)).

l_set : Label := dk_list.cons dk_char.char dk_char.s (
                 dk_list.cons dk_char.char dk_char.e (
                 dk_list.cons dk_char.char dk_char.t (
                 dk_list.nil dk_char.char))).

d_get_set : Domain := dk_lrecords.domain_cons l_get
                        (dk_lrecords.domain_cons l_set
                           dk_lrecords.domain_nil).

PromCell : Record d_get_set
:=
     dk_lrecords.AssocT_list_record
               (l : Label => cc.uuT)
               (AssocTT_cons (mk_coupleTT l_get dk_nat.Nat) (
               (AssocTT_cons (mk_coupleTT l_set
                         (cc.Arrow dk_nat.Nat (expr d_get RomCell))) (
               (AssocTT_nil))))).

l_contents : Label := dk_list.cons dk_char.char dk_char.c (
                      dk_list.cons dk_char.char dk_char.o (
                      dk_list.cons dk_char.char dk_char.n (
                      dk_list.cons dk_char.char dk_char.t (
                      dk_list.cons dk_char.char dk_char.e (
                      dk_list.cons dk_char.char dk_char.n (
                      dk_list.cons dk_char.char dk_char.t (
                      dk_list.cons dk_char.char dk_char.s (
                      dk_list.nil dk_char.char)))))))).

d_gsc : Domain := dk_lrecords.domain_cons l_get (
                                          dk_lrecords.domain_cons l_set
                                            (dk_lrecords.domain_cons l_contents
                                            dk_lrecords.domain_nil)).

PrivateCell : Record d_gsc
:=
     dk_lrecords.AssocT_list_record
               (l : Label => cc.uuT)
               (AssocTT_cons (mk_coupleTT l_get dk_nat.Nat) (
               (AssocTT_cons (mk_coupleTT l_set
                         (cc.Arrow dk_nat.Nat (expr d_get RomCell))) (
               (AssocTT_cons (mk_coupleTT l_contents dk_nat.Nat)
               (AssocTT_nil)))))).

Private_to_Prom : Expr d_gsc PrivateCell
                  -> Expr d_get_set PromCell
:= cast d_gsc d_get_set PrivateCell PromCell.

Private_to_Rom : Expr d_gsc PrivateCell
                  -> Expr d_get RomCell
:= cast d_gsc d_get PrivateCell RomCell.


myCell : Expr d_get_set PromCell
:=
    Private_to_Prom (
      make d_gsc PrivateCell
      (l : Label =>
           dk_lrecords.if_label_eq (lmethod d_gsc PrivateCell) l_contents l
              (self : Expr d_gsc PrivateCell => dk_nat.O)
              (dk_lrecords.if_label_eq (lmethod d_gsc PrivateCell) l_get l
                   (self : Expr d_gsc PrivateCell => select d_gsc PrivateCell self l_contents)
                   (dk_lrecords.if_label_eq (lmethod d_gsc PrivateCell) l_set l
                      (self : Expr d_gsc PrivateCell => n : dk_nat.N => Private_to_Rom (update d_gsc PrivateCell self l_contents (s : Expr d_gsc PrivateCell => n)))
                      (; Default case ;)
                      (self : Expr d_gsc PrivateCell => dk_fail.fail (PrivateCell l)))))).

(; The following check makes Dedukti use all the RAM… ;)
:= select d_get RomCell
   (select d_get_set PromCell myCell l_set dk_nat.__3)
   l_get.

